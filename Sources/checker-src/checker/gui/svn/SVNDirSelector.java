/**
 * 
 *   Copyright (C) 2008 Lasse Parikka
 *
 *   This program is free software; you can redistribute it and/or modify it under the terms of
 *   the GNU General Public License as published by the Free Software Foundation; either version 2
 *   of the License, or (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
 *   without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
 *   See the GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License along with this program;
 *   if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, 
 *   MA 02111-1307 USA
 *
 *   Also add information on how to contact you by electronic and paper mail.
 *
 */
package checker.gui.svn;

import java.awt.Component;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.ListIterator;
import java.util.regex.Pattern;

import javax.swing.JLabel;
import javax.swing.JTree;
import javax.swing.event.TreeExpansionEvent;
import javax.swing.event.TreeExpansionListener;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.event.TreeWillExpandListener;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.ExpandVetoException;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreePath;
import javax.swing.tree.TreeSelectionModel;

import org.jdesktop.swingworker.SwingWorker;

import checker.repository.SVNRepositoryEntry;
import checker.repository.SVNRepositoryPackage;
import checker.localization.Locale;

/**
 * Asks user to select which directory to checkout. 
 * Forms a directory tree from the repository.
 */
public class SVNDirSelector extends javax.swing.JDialog
implements TreeExpansionListener, TreeWillExpandListener, TreeSelectionListener{

	public SVNRepositoryPackage repository;
	private String repositoryUrl;
	public DefaultTreeModel treeModel;
	private String svnPath;
	private String selectedPath = "";
	private boolean expandTask = true;
	private String selectedFolder;
	/* Localization */
	private Locale loc = new Locale();

	/** Creates new form SVNDirSelector */
	public SVNDirSelector(java.awt.Frame parent, boolean modal, 
			SVNRepositoryPackage svnPackage,
			String pathRelativeToRoot) {
		
		super(parent, modal);
		repository = svnPackage;
		repositoryUrl = repository.getRootPath();
		svnPath = pathRelativeToRoot;
		initComponents();
	}

	/** This method is called from within the constructor to
	 * initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
	@SuppressWarnings("unchecked")
	// <editor-fold defaultstate="collapsed" desc="Generated Code">
	private void initComponents() {

		cancelButton = new javax.swing.JButton();
		jLabel1 = new javax.swing.JLabel();
		helpButton = new javax.swing.JButton();
		okButton = new javax.swing.JButton();
		jScrollPane1 = new javax.swing.JScrollPane();
		this.setTitle(loc.lc("Browse repository folders"));
		DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode(
				new SVNRepositoryEntry(loc.lc("Pending..."), false, null, null, null, 0));
		JTree tree = new JTree(rootNode);
		tree.addTreeExpansionListener(this);
		tree.addTreeWillExpandListener(this);
		tree.setCellRenderer(new TreeRenderer());
		tree.putClientProperty("JTree.lineStyle", "None");
		OpenTask getRoot = new OpenTask(null, 0);
		getRoot.execute();
		jScrollPane1.setViewportView(tree);


		setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
		setName("Form"); // NOI18N

		cancelButton.setText(loc.lc("Cancel")); // NOI18N
		cancelButton.setName("cancelButton"); // NOI18N
		cancelButton.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				cancelButtonActionPerformed(evt);
			}
		});

		jLabel1.setText(loc.lc("Choose the folder(s) you want to checkout from the repository.")); // NOI18N
		jLabel1.setName("jLabel1"); // NOI18N

		helpButton.setText(loc.lc("Help")); // NOI18N
		helpButton.setEnabled(false);
		helpButton.setName("helpButton"); // NOI18N
		helpButton.setPreferredSize(new java.awt.Dimension(75, 25));

		okButton.setText(loc.lc("OK")); // NOI18N
		okButton.setName("okButton"); // NOI18N
		okButton.setPreferredSize(new java.awt.Dimension(75, 25));
		okButton.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				okButtonActionPerformed(evt);
			}
		});
		jScrollPane1.setName("jScrollPane1"); // NOI18N

		 org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
	        getContentPane().setLayout(layout);
	        layout.setHorizontalGroup(
	            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
	            .add(layout.createSequentialGroup()
	                .addContainerGap()
	                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
	                    .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 432, Short.MAX_VALUE)
	                    .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
	                        .add(okButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
	                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
	                        .add(cancelButton)
	                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
	                        .add(helpButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
	                    .add(jLabel1))
	                .addContainerGap())
	        );
	        layout.setVerticalGroup(
	            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
	            .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
	                .addContainerGap()
	                .add(jLabel1)
	                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
	                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 247, Short.MAX_VALUE)
	                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
	                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
	                    .add(helpButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
	                    .add(cancelButton)
	                    .add(okButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
	                .addContainerGap())
	        );

		pack();
	}// </editor-fold>

	private void cancelButtonActionPerformed(java.awt.event.ActionEvent evt) {
		this.setVisible(false);
	}
	
	//user press ok button.
	private void okButtonActionPerformed(java.awt.event.ActionEvent evt) {
		//set this dialog invisible
		this.setVisible(false);
	}


	public void treeCollapsed(TreeExpansionEvent arg0) {
		// TODO Auto-generated method stub

	}

	
	public void treeExpanded(TreeExpansionEvent arg0) {
		// TODO Auto-generated method stub

	}

	
	public void treeWillCollapse(TreeExpansionEvent event)
	throws ExpandVetoException {
		// TODO Auto-generated method stub

	}

	public void treeWillExpand(TreeExpansionEvent event)
	throws ExpandVetoException {
		if (expandTask == true) {
        		TreePath path = event.getPath();
        		Object lastPathComponent = path.getLastPathComponent();
        		DefaultMutableTreeNode node = (DefaultMutableTreeNode)lastPathComponent;
        		OpenTask newTask = new OpenTask(node, 1);
        		//show "pending" text to the user 
        		//if folder contents is not yet loaded
        		SVNRepositoryEntry firstleaf = (SVNRepositoryEntry) ((DefaultMutableTreeNode) 
        				node.getChildAt(0)).getUserObject();
        		
        		if (firstleaf.getAuthor() == null) {
        			
        			treeModel.removeNodeFromParent((DefaultMutableTreeNode)node.getChildAt(0));
        			treeModel.insertNodeInto(new DefaultMutableTreeNode(new SVNRepositoryEntry(loc.lc("Pending..."), 
						false, null, null, null, 0)), node, 0);
        			
        		}
        		newTask.execute();
		}

	}
	
	/**
	 * Item selection listener.
	 */
	public void valueChanged(TreeSelectionEvent arg0) {
		
		//Returns the last path element of the selection.
		DefaultMutableTreeNode node = (DefaultMutableTreeNode)
		      tree.getLastSelectedPathComponent();
		if (node != null ) {
			
			SVNRepositoryEntry selectedEntry = (SVNRepositoryEntry)node.getUserObject();
			if (!selectedEntry.isFolderNode()) {
				tree.setSelectionPath(null);
			}
			else {
				selectedPath = selectedEntry.getPath();
				selectedFolder = selectedEntry.toString();
			}
		}
		
	}
	
	/**
	 * Returns user selected folder or "" if nothing
	 * was selected.
	 */
	public String getSelectedPath() {
		return selectedPath;
	}
	
	public String getSelectedFoldername() {
		return selectedFolder;
	}

	
	/**
	 * Creates a tree from repository root and svnPath.
	 */
	public void createTree(ArrayList<SVNRepositoryEntry> entries) {

		ListIterator<SVNRepositoryEntry> litr = entries.listIterator();
		DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode(new SVNRepositoryEntry(repositoryUrl, 
				false, "", null, null, 0));
		DefaultMutableTreeNode currentNode = rootNode;
		//split svnPath to folders
		Pattern p = Pattern.compile("/");
		String[] items = p.split(svnPath);
		String path = "";
		int i = 0;
		for (i = 0; i < items.length; i++) {
			if (items[i].length() > 0) {
				path += "/" + items[i];
				DefaultMutableTreeNode newNode = new DefaultMutableTreeNode(new 
						SVNRepositoryEntry(items[i], false, path, null, null, 0));
				currentNode.add(newNode);
				currentNode = newNode;
				
			}
		}
        	  
		while (litr.hasNext()) {
			SVNRepositoryEntry svnNode = litr.next();
			DefaultMutableTreeNode newNode = new DefaultMutableTreeNode(svnNode);
			if (svnNode.isFolderNode()) {
				newNode.add(new DefaultMutableTreeNode(new SVNRepositoryEntry(loc.lc("Pending..."), 
						false, null, null, null, 0)));
			}
			currentNode.add(newNode);
		}
		treeModel = new DefaultTreeModel(rootNode);
		tree = new JTree(treeModel);
		tree.addTreeExpansionListener(this);
		tree.addTreeWillExpandListener(this);
		tree.setCellRenderer(new TreeRenderer());
		tree.putClientProperty("JTree.lineStyle", "None");
		tree.addTreeSelectionListener(this);
		tree.getSelectionModel().setSelectionMode
	            (TreeSelectionModel.SINGLE_TREE_SELECTION);
		jScrollPane1.setViewportView(tree);
		expandTask = false;
		tree.expandPath(new TreePath(currentNode.getPath()));
		expandTask = true;
	}
	
	

	/**
	 * A worker thread that loads a repository path.
	 */
	class OpenTask extends SwingWorker<DefaultMutableTreeNode, Void> {

		private DefaultMutableTreeNode expand;
		private int mode;

		public OpenTask(DefaultMutableTreeNode e, int m) {
			mode = m;
			expand = e;

		}

		
		protected DefaultMutableTreeNode doInBackground() throws Exception {
			String path = null;
			if (mode == 0) {
				ArrayList<SVNRepositoryEntry> entries = 
					repository.listEntries(svnPath);
				//sort the list.
				Collections.sort(entries, new EntryComparator());
				createTree(entries);
			}
			else {
				DefaultMutableTreeNode firstleaf = (DefaultMutableTreeNode)expand.getChildAt(0);
				SVNRepositoryEntry firstleaf2 = (SVNRepositoryEntry) firstleaf.getUserObject(); 
				//load folder contents if it's not already loaded
				if (firstleaf.toString().equals(loc.lc("Pending...")) || 
						firstleaf2.getAuthor() == null) {

					SVNRepositoryEntry svnNode = (SVNRepositoryEntry)expand.getUserObject();
					path = svnNode.getPath();
					ArrayList<SVNRepositoryEntry> entries = 
						repository.listEntries(path);
					//sort the list.
					Collections.sort(entries, new EntryComparator());
					
					ListIterator<SVNRepositoryEntry> litr = entries.listIterator();


					while (litr.hasNext()) {
						SVNRepositoryEntry newSvnNode = litr.next();
						DefaultMutableTreeNode newNode = new DefaultMutableTreeNode(newSvnNode);
						if (newSvnNode.isFolderNode()) {
							newNode.add(new DefaultMutableTreeNode(new SVNRepositoryEntry(loc.lc("Pending..."), 
									false, null, null, null, 0)));
						}
						treeModel.insertNodeInto(newNode, expand, treeModel.getChildCount(expand));


					}
					treeModel.removeNodeFromParent((DefaultMutableTreeNode)expand.getChildAt(0));
				}


			}

			return null;
		}



	}
	/**
	 * Renders the loading text("pending...") without icon.
	 */
	private class TreeRenderer extends DefaultTreeCellRenderer {


		public Component getTreeCellRendererComponent(
				JTree tree,
				Object value,
				boolean sel,
				boolean expanded,
				boolean leaf,
				int row,
				boolean hasFocus) {

			super.getTreeCellRendererComponent(
					tree, value, sel,
					expanded, leaf, row,
					hasFocus);
			if (leaf && isLoadingText(value)) {
				setIcon(null);
			}
			return this;
		}

		protected boolean isLoadingText(Object value) {
			DefaultMutableTreeNode node =
				(DefaultMutableTreeNode)value;
			SVNRepositoryEntry nodeInfo = 
				(SVNRepositoryEntry)(node.getUserObject());
			String name = nodeInfo.toString();
			if (name.equals(loc.lc("Pending..."))) {
				return true;
			} 

			return false;
		}
	}
	
	/**
	 * Comparator class for sorting the tree.
	 * @author lparikka
	 */
	public class EntryComparator implements Comparator<SVNRepositoryEntry> {

		
		//@Override
		public int compare(SVNRepositoryEntry arg0, SVNRepositoryEntry arg1) {
			if ((arg0.isFolderNode() && arg1.isFolderNode()) || 
					(!arg0.isFolderNode() && !arg1.isFolderNode())) {
				return arg0.toString().toLowerCase().compareTo(arg1.toString().toLowerCase());
			}
			if (arg0.isFolderNode() && !arg1.isFolderNode()) {
				return -1;
			}
			if (!arg0.isFolderNode() && arg1.isFolderNode()) {
				return 1;
			}
			return 0;
		}
		
	}

	// Variables declaration - do not modify
	private javax.swing.JButton cancelButton;
	private javax.swing.JButton helpButton;
	private javax.swing.JLabel jLabel1;
	private javax.swing.JScrollPane jScrollPane1;
	private javax.swing.JButton okButton;
	private JTree tree;
	// End of variables declaration

	
}
//Reviewed by mkupsu 29.11.8
